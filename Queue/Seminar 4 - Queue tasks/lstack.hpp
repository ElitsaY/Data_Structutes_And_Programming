// FROM LECTURES - https://github.com/triffon/sdp-2022-23
#ifndef __LSTACK_HPP
#define __LSTACK_HPP
#include <cassert>
#include <cstddef>
#include <iostream>

#include "abstract_stack.hpp"

template <typename T>
struct StackElement {
	T data;
	StackElement<T>* next;
};

template <typename T>
class LinkedStack : public AbstractStack<T> {
private:
	// ???????? ??? ???????? ?????, ????? ? ???? ?? ?????
	StackElement<T>* top;

	// ???????? ?? ????
	void copyStack(LinkedStack const&);

	// ????????? ?? ????
	void erase();

public:
	// ????????? ?? ?????? ????
	LinkedStack();

	// ??????????? ?? ????????
	LinkedStack(LinkedStack const&);

	// ???????? ?? ???????????
	LinkedStack& operator=(LinkedStack const&);

	// ??????????? ?? ???????????
	LinkedStack(LinkedStack&&);

	// ???????? ?? ???????????
	LinkedStack& operator=(LinkedStack&&);

	// ??????????
	~LinkedStack();

	// ???????? ?? ????????
	bool empty() const;

	// ????????? ?? ???????
	void push(T const& x);

	// ???????? ?? ????????? ??????? ???????
	T const& peek() const;

	// ????????? ???????? ?? ????????? ??????? ??????? ? ????????? ?? ?????
	bool peek(T&) const;


	// ?????????? ?? ????????? ??????? ???????
	T pop();

	// ?????????? ?? ????????? ??????? ??????? ? ??? ?? ??????
	T pop(bool& success);

	void steal(LinkedStack&& other) {
		if (top != nullptr)
			//erase();
			throw std::runtime_error("?????? ?? ???????? ?????!");
		top = other.top;
		other.top = nullptr;
	}
};


// ????????? ?? ?????? ????
// O(1)
template <typename T>
LinkedStack<T>::LinkedStack() : top(nullptr) {}

// ???????? ?? ????
template <typename T>
LinkedStack<T>::LinkedStack(LinkedStack const& other) : top(nullptr) {
	std::clog << "???????? ?? LinkedStack" << std::endl;
	copyStack(other);
}

// ??????????
template <typename T>
LinkedStack<T>::~LinkedStack() {
	erase();
}

template <typename T>
void LinkedStack<T>::erase() {
	// !!! delete top;
	while (!empty()) pop();
	// ???????: ???????????? ?? ???????? ? ?????????????
}

template <typename T>
void LinkedStack<T>::copyStack(LinkedStack const& other) {
	if (other.top != nullptr) {
		// other ?? ? ??????
		StackElement<T>* lastAdded = top = new StackElement<T>{ other.top->data, nullptr };
		StackElement<T>* nextToCopy = other.top->next;
		while (nextToCopy) {
			lastAdded = lastAdded->next = new StackElement<T>{ nextToCopy->data, nullptr };
			nextToCopy = nextToCopy->next;
		}
	}
}

template <typename T>
LinkedStack<T>& LinkedStack<T>::operator=(LinkedStack const& other) {
	std::clog << "??????????? ?? LinkedStack" << std::endl;
	if (this != &other) {
		erase();
		copyStack(other);
	}
	return *this;
}


// ???????? ?? ????????
// O(1)
template <typename T>
bool LinkedStack<T>::empty() const {
	return top == nullptr;
}

// ????????? ?? ???????
// O(1)
template <typename T>
void LinkedStack<T>::push(T const& x) {
	top = new StackElement<T>{ x, top };
}

// ?????????? ?? ????????? ??????? ???????
// O(1)
template <typename T>
T const& LinkedStack<T>::peek() const {
	if (empty())
		throw std::runtime_error("???? ?? ?????????? ?? ??????? ? ?????? ????");
	return top->data;
}

// ?????????? ?? ????????? ??????? ???????
// O(1)
template <typename T>
bool LinkedStack<T>::peek(T& result) const {
	if (empty())
		return false;
	result = top->data;
	return true;
}

// ?????????? ?? ????????? ??????? ???????
// O(1)
template <typename T>
T LinkedStack<T>::pop() {
	if (empty())
		throw std::runtime_error("???? ?? ?????????? ?? ??????? ? ?????? ????");
	StackElement<T>* newtop = top->next;
	T x = top->data;
	delete top;
	top = newtop;
	return x;
}

// ?????????? ?? ????????? ??????? ???????
// O(1)
template <typename T>
T LinkedStack<T>::pop(bool& success) {
	if (empty()) {
		success = false;
		return T();
	}
	success = true;
	return pop();
}

// O(1)
template <typename T>
LinkedStack<T>::LinkedStack(LinkedStack&& other) : top(other.top) {
	std::clog << "??????????? ?? ??????????? ?? LinkedStack" << std::endl;
	other.top = nullptr;
}

// 
template <typename T>
LinkedStack<T>& LinkedStack<T>::operator=(LinkedStack&& other) {
	std::cout << "???????? ?? ??????????? ?? LinkedStack" << std::endl;
	if (this != &other) {
		erase();
		top = other.top;
		other.top = nullptr;
	}
	return *this;
}

#endif